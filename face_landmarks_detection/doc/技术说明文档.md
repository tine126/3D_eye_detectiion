# face_landmarks_detection 技术说明文档

**版本**: 2.3.1
**平台**: RDK X3 / RDK X5 (地平线 D-Robotics)
**功能**: 人脸106关键点检测
**维护者**: zhikang.zeng@d-robotics.cc

---

## 目录

- [(A) 仓库地图](#a-仓库地图)
- [(B) Targets 清单](#b-targets-清单)
- [(C) 推理链路拆解](#c-推理链路拆解)
- [(D) ROS2 接口表](#d-ros2-接口表)
- [(E) 参数体系](#e-参数体系)
- [(F) 性能与稳定性](#f-性能与稳定性)
- [(G) 二次开发方案](#g-二次开发人眼定位定制方案)

---

## (A) 仓库地图

### 目录树（≤3层）

```
face_landmarks_detection/
├── CMakeLists.txt                        # 构建配置
├── package.xml                           # ROS2 包描述
├── README.md / README_CN.md              # 文档
├── LICENSE                               # Apache-2.0
├── config/
│   ├── image.png                         # 测试图片
│   ├── x3/
│   │   └── faceLandmark106pts.hbm        # X3平台模型
│   └── x5/
│       └── faceLandmark106pts.hbm        # X5平台模型
├── doc/
│   └── face_landmarks_det_render.png     # 效果示例图
├── include/
│   ├── face_landmarks_det_node.h         # 主节点头文件
│   ├── face_landmarks_det_output_parser.h # 输出解析器
│   ├── ai_msg_manage.h                   # AI消息管理
│   └── img_convert_utils.h               # 图像转换工具
├── launch/
│   ├── face_landmarks_det_node.launch.py        # 单节点启动
│   ├── body_det_face_landmarks_det.launch.py    # 联合检测启动
│   └── body_det_face_landmarks_det_fb.launch.py # 回放+Web可视化
└── src/
    ├── main.cpp                          # 程序入口
    ├── face_landmarks_det_node.cpp       # 主节点实现
    ├── face_landmarks_det_output_parser.cpp # 后处理解析
    ├── ai_msg_manage.cpp                 # AI消息缓存管理
    └── img_convert_utils.cpp             # NV12/BGR转换(NEON优化)
```

### 模块职责与边界

| 模块 | 文件 | 职责 | 边界 |
|------|------|------|------|
| **主节点** | `face_landmarks_det_node.h/cpp` | ROS2节点生命周期、参数管理、订阅/发布、推理调度 | 继承自`DnnNode`，调用`dnn_node`库 |
| **输出解析** | `face_landmarks_det_output_parser.h/cpp` | 模型输出张量解析、关键点坐标计算、亚像素插值 | 仅处理`DNNTensor`到`FaceLandmarksDetResult`转换 |
| **消息管理** | `ai_msg_manage.h/cpp` | AI消息时间戳缓存、图像-检测结果匹配 | 基于优先队列的时间戳同步机制 |
| **图像工具** | `img_convert_utils.h/cpp` | BGR↔NV12颜色空间转换 | ARM NEON SIMD加速 |

---

## (B) Targets 清单

### 可执行文件: `face_landmarks_detection`

| 属性 | 值 | 定位 |
|------|-----|------|
| **入口文件** | `src/main.cpp:18-24` | `main()` → `rclcpp::spin(FaceLandmarksDetNode)` |
| **源文件** | `main.cpp`, `face_landmarks_det_node.cpp`, `face_landmarks_det_output_parser.cpp`, `ai_msg_manage.cpp`, `img_convert_utils.cpp` | `CMakeLists.txt:64` |
| **编译标准** | C99 / C++17 | `CMakeLists.txt:65` |
| **编译宏** | `SHARED_MEM_ENABLED` | `CMakeLists.txt:41` |

### 依赖关系

| 依赖类型 | 依赖项 | 用途 |
|----------|--------|------|
| **ROS2** | `rclcpp`, `sensor_msgs`, `ai_msgs`, `hbm_img_msgs` | 节点框架、消息类型 |
| **推理** | `dnn_node` (hobot_dnn) | DNN推理封装 |
| **图像** | `OpenCV` | 图像读取、渲染 |
| **底层** | `libdnn.so` (hbbpu) | BPU硬件推理 |

### 平台编译选项

| 平台 | CMake选项 | 模型路径 |
|------|-----------|----------|
| X3 | `-DPLATFORM_X3=ON` | `config/x3/` |
| X5 | `-DPLATFORM_X5=ON` | `config/x5/` |
| Rdkultra | `-DPLATFORM_Rdkultra=ON` | `config/rdkultra/` |

### 安装资源

```cmake
# CMakeLists.txt:82-85
install(TARGETS face_landmarks_detection DESTINATION lib/${PROJECT_NAME})
install(DIRECTORY launch DESTINATION share/${PROJECT_NAME})
install(DIRECTORY config/${PREFIX_PATH}/ DESTINATION share/${PROJECT_NAME}/config/)
install(FILES config/image.png DESTINATION share/${PROJECT_NAME}/config/)
```

---

## (C) 推理链路拆解

### 整体流程图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              输入来源                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  [在线模式 feed_type=0]                    [离线模式 feed_type=1]           │
│  ┌──────────────────┐                      ┌──────────────────┐             │
│  │ SharedMem Topic  │ (/hbmem_img)         │ 本地图片         │             │
│  │ HbmMsg1080P      │                      │ cv::imread()     │             │
│  └────────┬─────────┘                      └────────┬─────────┘             │
│           │                                         │                        │
│  ┌────────┴─────────┐                               │                        │
│  │ ROS Image Topic  │ (/image_raw)                  │                        │
│  │ sensor_msgs/Image│                               │                        │
│  └────────┬─────────┘                               │                        │
│           ↓                                         ↓                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                              预处理                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. 颜色空间转换: BGR → NV12 (NEON加速)                                      │
│  2. 金字塔构建: GetNV12PyramidFromNV12Img()                                  │
│  3. ROI扩展: expand_scale=1.25, 中心扩展                                     │
│  4. ROI对齐: left/top偶数, right/bottom奇数                                  │
│  5. ROI尺寸约束: 16 < size < 255                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                              推理                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│  框架: hobot_dnn (dnn_node) → BPU硬件加速                                    │
│  模型: faceLandmark106pts.hbm (地平线专有格式)                               │
│  任务类型: ModelRoiInferType (ROI推理)                                       │
│  并发: task_num=4                                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                              后处理                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. 张量解析: 2个输出张量(X方向/Y方向), NHWC布局, S32类型                    │
│  2. 反量化: SHIFT/SCALE/NONE三种模式                                         │
│  3. 坐标计算: argmax + 亚像素插值(±0.25)                                     │
│  4. 坐标映射: 归一化 → 像素坐标 (基于ROI)                                    │
│  5. 输出: 106个关键点 (x, y, score)                                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1. 输入来源详解

| 模式 | 参数 | 数据源 | 回调函数 | 定位 |
|------|------|--------|----------|------|
| **SharedMem** | `is_shared_mem_sub=1` | `/hbmem_img` (HbmMsg1080P) | `SharedMemImgProcess()` | `face_landmarks_det_node.cpp:640-706` |
| **ROS Image** | `is_shared_mem_sub=0` | `/image_raw` (sensor_msgs/Image) | `RosImgProcess()` | `face_landmarks_det_node.cpp:488-553` |
| **离线图片** | `feed_type=1` | 本地PNG/JPG | `Feedback()` | `face_landmarks_det_node.cpp:387-464` |
| **AI消息** | - | `/hobot_mono2d_body_detection` | `AiMsgProcess()` | `face_landmarks_det_node.cpp:474-486` |

### 2. 预处理详解

**颜色空间转换** (`img_convert_utils.cpp:84-175`)
```cpp
// BGR24 → NV12 (ARM NEON SIMD优化)
void bgr24_to_nv12_neon(uint8_t *bgr24, uint8_t *nv12, int width, int height)
// Y = 66*R + 129*G + 25*B + 128 >> 8 + 16
// U = -38*R - 74*G + 112*B + 128 >> 8 + 128
// V = 112*R - 94*G - 18*B + 128 >> 8 + 128
```

**金字塔构建** (`face_landmarks_det_node.cpp:406-407`)
```cpp
pyramid = hobot::dnn_node::ImageProc::GetNV12PyramidFromNV12Img(
    reinterpret_cast<const char *>(feed_img_bgr_nv12.data),
    height, width, height, width);
```

**ROI归一化** (`face_landmarks_det_node.cpp:784-858`)
```cpp
int FaceLandmarksDetNode::NormalizeRoi(const hbDNNRoi *src, hbDNNRoi *dst,
                                       float norm_ratio, uint32_t total_w, uint32_t total_h)
{
    // 1. 中心扩展 (expand_scale=1.25)
    h_new = box_h * norm_ratio;
    w_new = box_w * norm_ratio;

    // 2. 边界裁剪
    dst->left = dst->left < 0 ? 0.0f : dst->left;

    // 3. 奇偶对齐 (BPU硬件要求)
    dst->left += (dst->left % 2 == 0 ? 0 : 1);   // 偶数
    dst->right -= (dst->right % 2 == 1 ? 0 : 1); // 奇数

    // 4. 尺寸约束检查
    if (max_size < roi_size_max_ && min_size > roi_size_min_) // [16, 255)
        return 0;
    return -1;
}
```

### 3. 推理框架

| 属性 | 值 | 定位 |
|------|-----|------|
| **推理框架** | `hobot_dnn` (dnn_node) | `CMakeLists.txt:52` |
| **底层库** | `libdnn.so` (BPU) | `CMakeLists.txt:69-71` |
| **模型格式** | `.hbm` (地平线专有) | `config/x3/faceLandmark106pts.hbm` |
| **任务类型** | `ModelRoiInferType` | `face_landmarks_det_node.h:173` |
| **并发任务数** | 4 | `face_landmarks_det_node.cpp:157` |
| **同步/异步** | 可配置 (`is_sync_mode`) | `face_landmarks_det_node.cpp:470` |

**推理调用** (`face_landmarks_det_node.cpp:466-471`)
```cpp
int FaceLandmarksDetNode::Predict(std::vector<std::shared_ptr<DNNInput>> &inputs,
                                  const std::shared_ptr<std::vector<hbDNNRoi>> rois,
                                  std::shared_ptr<DnnNodeOutput> dnn_output)
{
    return Run(inputs, dnn_output, rois, is_sync_mode_ == 1 ? true : false);
}
```

### 4. 后处理详解

**输出张量结构** (`face_landmarks_det_output_parser.cpp:46-48`)
```cpp
// 2个输出张量: output_tensors[0]=X方向, output_tensors[1]=Y方向
// 类型: HB_DNN_TENSOR_TYPE_S32
// 布局: HB_DNN_LAYOUT_NHWC
// Shape: [batch, H, W, 106] 或 [batch, 1, 32, 106]
```

**坐标计算算法** (`face_landmarks_det_output_parser.cpp:105-251`)
```cpp
// 1. 找最大值索引 (argmax)
for (int i = 0; i < vector_size; ++i) {
    float value = quanti_shift(data[index], shift); // 反量化
    if (value > max_value) {
        max_value = value;
        max_index = i;
    }
}

// 2. 亚像素插值
float diff = right_val - left_val;
if (diff > 0) diff = 0.25;
else if (diff < 0) diff = -0.25;
max_index = max_index + (diff * 1.0 + 0.5);

// 3. 映射到像素坐标
x = max_index * roi_width / vector_size + roi.left;
y = max_index * roi_height / vector_size + roi.top;
```

**输出格式**
- 坐标系: **像素坐标** (相对于原图)
- 关键点数: **106个**
- 每点属性: `(x, y, score)` - `face_landmarks_det_output_parser.h:27-41`

---

## (D) ROS2 接口表

### Topics

| Topic名称 | 消息类型 | 方向 | QoS | 节点 | 定位 |
|-----------|----------|------|-----|------|------|
| `/hbmem_img` | `hbm_img_msgs/HbmMsg1080P` | Sub | SensorDataQoS | face_landmarks_det_node | `face_landmarks_det_node.cpp:118` |
| `/image_raw` | `sensor_msgs/Image` | Sub | 10 | face_landmarks_det_node | `face_landmarks_det_node.cpp:127` |
| `/hobot_mono2d_body_detection` | `ai_msgs/PerceptionTargets` | Sub | 10 | face_landmarks_det_node | `face_landmarks_det_node.cpp:112` |
| `/face_landmarks_detection` | `ai_msgs/PerceptionTargets` | Pub | 10 | face_landmarks_det_node | `face_landmarks_det_node.cpp:109` |

### 消息结构详解

**输入: ai_msgs/PerceptionTargets** (人脸检测结果)
```yaml
header:
  stamp: builtin_interfaces/Time
  frame_id: string
fps: float32
targets[]:
  type: string          # "person"
  track_id: uint64
  rois[]:
    type: string        # "face" - 关键过滤条件
    rect:
      x_offset: uint32  # 人脸框左上角X
      y_offset: uint32  # 人脸框左上角Y
      width: uint32     # 人脸框宽度
      height: uint32    # 人脸框高度
```

**输出: ai_msgs/PerceptionTargets** (关键点结果)
```yaml
header: std_msgs/Header
fps: float32
targets[]:
  type: string
  track_id: uint64
  rois[]:               # 原始人脸框
    type: "face"
    rect: sensor_msgs/RegionOfInterest
  points[]:             # 新增: 关键点数组
    type: "face_kps"    # 关键点类型标识
    point[]:            # 106个点
      x: float32        # 像素X坐标
      y: float32        # 像素Y坐标
      z: float32        # 未使用
perfs[]:                # 性能统计
  type: string          # "faceLandmark106pts_preprocess/predict_infer/predict_parse/postprocess/pipeline"
  stamp_start: Time
  stamp_end: Time
  time_ms_duration: int32
```

### Services/Actions

**无** - 本仓库未定义任何Service或Action接口。

---

## (E) 参数体系

### 参数声明位置

所有参数在 `FaceLandmarksDetNode` 构造函数中声明:
`face_landmarks_det_node.cpp:36-47`

### 参数清单

| 参数名 | 类型 | 默认值 | 声明位置 | 影响 |
|--------|------|--------|----------|------|
| `feed_type` | int | 0 | L36 | **性能** 0=在线推理, 1=离线推理 |
| `feed_image_path` | string | `./config/image.png` | L37 | 离线模式图片路径 |
| `roi_xyxy` | string | `"0,0,0,0"` | L38 | 离线模式ROI坐标 |
| `is_sync_mode` | int | 0 | L39 | **性能** 0=异步, 1=同步 |
| `model_file_name` | string | `./config/faceLandmark106pts.hbm` | L40 | **精度** 模型文件路径 |
| `is_shared_mem_sub` | int | 1 | L41 | **性能** 0=ROS话题, 1=共享内存 |
| `dump_render_img` | int | 0 | L42 | 调试用渲染图保存 |
| `ai_msg_pub_topic_name` | string | `/face_landmarks_detection` | L43 | 发布话题名 |
| `ros_img_topic_name` | string | `/image_raw` | L44 | ROS图像订阅话题 |
| `sharedmem_img_topic_name` | string | `/hbmem_img` | L46 | 共享内存图像话题 |

### 内部硬编码参数

| 参数 | 值 | 位置 | 说明 |
|------|-----|------|------|
| `expand_scale_` | 1.25 | `face_landmarks_det_node.h:166` | ROI扩展比例 |
| `roi_size_max_` | 255 | `face_landmarks_det_node.h:169` | ROI最大尺寸 |
| `roi_size_min_` | 16 | `face_landmarks_det_node.h:170` | ROI最小尺寸 |
| `cache_len_limit_` | 8 | `face_landmarks_det_node.h:211` | 图像缓存队列长度 |
| `cache_limt_len_` | 20 | `ai_msg_manage.h:147` | AI消息缓存长度 |
| `task_num` | 4 | `face_landmarks_det_node.cpp:157` | 推理并发数 |

### 动态更新支持

**不支持** - 所有参数在构造函数中通过 `declare_parameter()` 声明，无 `add_on_set_parameters_callback()` 回调。参数变更需重启节点。

### 性能/精度影响参数

| 参数 | 影响类型 | 说明 |
|------|----------|------|
| `is_shared_mem_sub` | **性能** | 共享内存零拷贝，减少数据传输延迟 |
| `is_sync_mode` | **性能** | 同步模式阻塞等待，异步模式流水线 |
| `model_file_name` | **精度** | 不同平台模型精度可能不同 |
| `expand_scale_` | **精度** | ROI扩展影响关键点检测范围 |
| `roi_size_min/max` | **精度** | 过滤过大/过小人脸 |

---

## (F) 性能与稳定性

### 耗时统计位置

| 阶段 | 统计变量 | 位置 | 说明 |
|------|----------|------|------|
| **预处理** | `perf_preprocess` | `face_landmarks_det_node.cpp:332-334` | 图像接收→推理开始 |
| **推理** | `rt_stat->infer_time_ms` | `face_landmarks_det_node.cpp:339-344` | BPU推理耗时 |
| **解析** | `rt_stat->parse_time_ms` | `face_landmarks_det_node.cpp:346-350` | 张量解析耗时 |
| **后处理** | `perf_postprocess` | `face_landmarks_det_node.cpp:353-359` | 结果组装耗时 |
| **全链路** | `perf_pipeline` | `face_landmarks_det_node.cpp:362-367` | 图像发布→AI结果发布 |

**FPS统计** (`face_landmarks_det_node.cpp:177-186`)
```cpp
if (node_output->rt_stat->fps_updated) {
    RCLCPP_WARN_THROTTLE(..., 5000,
        "input fps: %.2f, out fps: %.2f, "
        "infer time ms: %d, post process time ms: %d",
        node_output->rt_stat->input_fps,
        node_output->rt_stat->output_fps,
        node_output->rt_stat->infer_time_ms,
        node_output->rt_stat->parse_time_ms);
}
```

### 瓶颈分析（代码证据）

#### 瓶颈1: 图像-AI消息时间戳同步等待

**证据**: `ai_msg_manage.cpp:42`
```cpp
ai_msg = face_landmarks_det_feed_cache_.Get(msg_ts, time_out_ms);  // 默认200ms超时
```

**问题**: 图像与AI消息异步到达，需等待匹配，最大200ms阻塞。

#### 瓶颈2: 后处理双重循环遍历

**证据**: `face_landmarks_det_output_parser.cpp:99-253`
```cpp
for (int b = 0; b < shape[0]; b++) {           // 遍历batch
    for (int point_idx = 0; point_idx < 106; ++point_idx) {  // 遍历106点
        for (int i = 0; i < vector_size; ++i) {  // 遍历32个bin
            // argmax计算
        }
    }
}
```

**问题**: 三重循环，每帧 `batch × 106 × 32 × 2` 次访存。

#### 瓶颈3: 渲染时NV12→BGR转换

**证据**: `face_landmarks_det_node.cpp:720-733`
```cpp
char *buf = new char[img_y_size + img_uv_size];  // 堆分配
memcpy(buf, y_img, img_y_size);                  // 拷贝Y
memcpy(buf + img_y_size, uv_img, img_uv_size);   // 拷贝UV
cv::cvtColor(nv12, bgr, cv::COLOR_YUV2BGR_NV12); // OpenCV转换
delete[] buf;
```

**问题**: 每帧渲染需2次memcpy + 1次颜色转换。

### 3个优化点与改法

#### 优化1: 减少时间戳同步等待

**问题**: 200ms超时过长

**改法**:
```cpp
// ai_msg_manage.h:91 - 减少超时时间
ai_msgs::msg::PerceptionTargets::UniquePtr Get(
    const std_msgs::msg::Header::_stamp_type &msg_ts,
    int time_out_ms = 50)  // 200ms → 50ms

// 或使用无锁队列替代条件变量等待
```

**预期收益**: 减少平均等待延迟100ms+

#### 优化2: 后处理SIMD加速

**问题**: argmax三重循环

**改法**:
```cpp
// face_landmarks_det_output_parser.cpp - 使用NEON加速argmax
#include <arm_neon.h>
// 将32个bin的argmax改为SIMD并行比较
int32x4_t max_vals = vdupq_n_s32(INT32_MIN);
int32x4_t max_idxs = vdupq_n_s32(0);
for (int i = 0; i < vector_size; i += 4) {
    int32x4_t vals = vld1q_s32(&data[base + i]);
    uint32x4_t mask = vcgtq_s32(vals, max_vals);
    max_vals = vbslq_s32(mask, vals, max_vals);
    max_idxs = vbslq_s32(mask, vdupq_n_s32(i), max_idxs);
}
```

**预期收益**: 后处理耗时减少50%+

#### 优化3: 避免渲染时内存拷贝

**问题**: 每帧2次memcpy

**改法**:
```cpp
// face_landmarks_det_node.cpp:720-733 - 直接使用pyramid地址
// 方案A: 使用NEON优化的nv12_to_bgr24_neon (已有实现)
cv::Mat bgr(height, width, CV_8UC3);
utils::nv12_to_bgr24_neon(
    reinterpret_cast<uint8_t*>(pyramid->y_vir_addr),
    bgr.data, width, height);

// 方案B: 仅在dump_render_img=1时执行，默认关闭
```

**预期收益**: 渲染耗时减少30%+

---

## (G) 二次开发：人眼定位定制方案

### 106关键点眼部索引参考

根据标准106点定义（需确认具体模型）：
- **左眼**: 点33-42 (眼轮廓), 点104 (瞳孔中心)
- **右眼**: 点87-96 (眼轮廓), 点105 (瞳孔中心)

> **注意**: 具体索引需根据实际模型输出验证，可通过离线推理+渲染确认。

---

### 方案1: 基于关键点直接输出人眼中心

#### 设计思路

从106关键点中提取眼部关键点，计算眼睛中心坐标，通过新Topic发布。

#### 修改文件清单

| 文件 | 修改内容 |
|------|----------|
| `include/face_landmarks_det_node.h` | 新增Publisher、参数声明 |
| `src/face_landmarks_det_node.cpp` | 新增眼部中心计算、发布逻辑 |
| `package.xml` | 新增消息依赖（如使用自定义msg） |

#### 新增消息/Topic

**方案A: 使用geometry_msgs/PointStamped**
```yaml
Topic: /eye_centers
Type: geometry_msgs/PoseArray
# poses[0] = 左眼中心, poses[1] = 右眼中心
```

**方案B: 自定义消息 (推荐)**
```yaml
# msg/EyeCenter.msg
std_msgs/Header header
uint64 track_id
geometry_msgs/Point32 left_eye   # 左眼中心 (x, y, z=置信度)
geometry_msgs/Point32 right_eye  # 右眼中心 (x, y, z=置信度)
float32 confidence               # 整体置信度
```

#### 参数设计

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `eye_center_pub_topic` | string | `/eye_centers` | 眼部中心发布话题 |
| `left_eye_indices` | string | `"33,34,35,36,37,38,39,40,41,42"` | 左眼关键点索引 |
| `right_eye_indices` | string | `"87,88,89,90,91,92,93,94,95,96"` | 右眼关键点索引 |
| `eye_center_method` | int | 0 | 0=轮廓平均, 1=瞳孔点 |

#### 核心代码示例

**头文件修改** (`face_landmarks_det_node.h`)
```cpp
// 新增Publisher
rclcpp::Publisher<geometry_msgs::msg::PoseArray>::SharedPtr eye_center_publisher_;
std::string eye_center_pub_topic_ = "/eye_centers";

// 眼部索引配置
std::vector<int> left_eye_indices_ = {33,34,35,36,37,38,39,40,41,42};
std::vector<int> right_eye_indices_ = {87,88,89,90,91,92,93,94,95,96};
```

**PostProcess中新增眼部中心计算** (`face_landmarks_det_node.cpp`)
```cpp
// 在PostProcess函数中，解析完关键点后添加:
geometry_msgs::msg::PoseArray eye_msg;
eye_msg.header = ai_msg->header;

for (size_t i = 0; i < face_landmarks_det_result->values.size(); i++) {
    const auto& landmarks = face_landmarks_det_result->values[i];

    // 计算左眼中心
    float left_x = 0, left_y = 0;
    for (int idx : left_eye_indices_) {
        left_x += landmarks[idx].x;
        left_y += landmarks[idx].y;
    }
    left_x /= left_eye_indices_.size();
    left_y /= left_eye_indices_.size();

    // 计算右眼中心
    float right_x = 0, right_y = 0;
    for (int idx : right_eye_indices_) {
        right_x += landmarks[idx].x;
        right_y += landmarks[idx].y;
    }
    right_x /= right_eye_indices_.size();
    right_y /= right_eye_indices_.size();

    // 填充消息
    geometry_msgs::msg::Pose left_eye, right_eye;
    left_eye.position.x = left_x;
    left_eye.position.y = left_y;
    right_eye.position.x = right_x;
    right_eye.position.y = right_y;

    eye_msg.poses.push_back(left_eye);
    eye_msg.poses.push_back(right_eye);
}

eye_center_publisher_->publish(eye_msg);
```

#### 方案1评估

| 维度 | 评估 |
|------|------|
| **延迟** | +0.1ms (仅增加简单计算) |
| **算力** | 可忽略 (几十次浮点运算) |
| **风险** | 低 - 不影响原有逻辑 |
| **精度** | 依赖106点模型精度，约±2-3像素 |

---

### 方案2: 输出眼部ROI供二阶段推理

#### 设计思路

基于眼部关键点计算眼部包围盒(ROI)，裁剪图像区域，供后续细分模型（如瞳孔检测、虹膜识别）进行二阶段推理。

#### 修改文件清单

| 文件 | 修改内容 |
|------|----------|
| `include/face_landmarks_det_node.h` | 新增ROI Publisher、图像裁剪函数 |
| `src/face_landmarks_det_node.cpp` | 新增眼部ROI计算、图像裁剪、发布逻辑 |
| `package.xml` | 新增 `sensor_msgs` 依赖 |
| `CMakeLists.txt` | 可能需要新增OpenCV依赖 |

#### 新增消息/Topic

**Topic设计**
```yaml
# ROI信息话题
Topic: /eye_rois
Type: ai_msgs/PerceptionTargets
# 复用现有消息结构，rois.type = "left_eye" / "right_eye"

# 裁剪图像话题 (可选)
Topic: /eye_roi_images
Type: sensor_msgs/Image
# 拼接后的眼部图像，用于可视化或二阶段推理
```

#### 参数设计

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `eye_roi_pub_topic` | string | `/eye_rois` | 眼部ROI发布话题 |
| `eye_roi_expand` | float | 1.5 | ROI扩展系数 |
| `eye_roi_min_size` | int | 32 | 最小ROI尺寸 |
| `pub_eye_roi_image` | int | 0 | 是否发布裁剪图像 |

#### 核心代码示例

**眼部ROI计算函数**
```cpp
struct EyeRoi {
    int left, top, right, bottom;
    float confidence;
};

EyeRoi CalculateEyeRoi(const Landmarks& landmarks,
                       const std::vector<int>& eye_indices,
                       float expand_ratio,
                       int img_w, int img_h) {
    float min_x = FLT_MAX, min_y = FLT_MAX;
    float max_x = 0, max_y = 0;
    float total_score = 0;

    for (int idx : eye_indices) {
        min_x = std::min(min_x, landmarks[idx].x);
        min_y = std::min(min_y, landmarks[idx].y);
        max_x = std::max(max_x, landmarks[idx].x);
        max_y = std::max(max_y, landmarks[idx].y);
        total_score += landmarks[idx].score;
    }

    // 中心扩展
    float cx = (min_x + max_x) / 2;
    float cy = (min_y + max_y) / 2;
    float w = (max_x - min_x) * expand_ratio;
    float h = (max_y - min_y) * expand_ratio;

    EyeRoi roi;
    roi.left = std::max(0, (int)(cx - w/2));
    roi.top = std::max(0, (int)(cy - h/2));
    roi.right = std::min(img_w, (int)(cx + w/2));
    roi.bottom = std::min(img_h, (int)(cy + h/2));
    roi.confidence = total_score / eye_indices.size();

    return roi;
}
```

#### 方案2评估

| 维度 | 评估 |
|------|------|
| **延迟** | +1-5ms (含图像裁剪) |
| **算力** | 中等 (ROI计算+图像裁剪) |
| **风险** | 中等 - 需处理边界情况 |
| **精度** | 可支持更高精度的二阶段模型 |

---

### 方案对比总结

| 对比维度 | 方案1: 直接输出眼中心 | 方案2: 输出眼部ROI |
|----------|----------------------|-------------------|
| **实现复杂度** | 低 | 中 |
| **新增延迟** | <0.1ms | 1-5ms |
| **算力消耗** | 可忽略 | 中等 |
| **精度上限** | 受限于106点模型 | 可扩展二阶段模型 |
| **适用场景** | 快速原型、精度要求不高 | 高精度瞳孔/虹膜检测 |
| **推荐度** | ★★★★☆ | ★★★☆☆ |

### 推荐实施路径

1. **第一阶段**: 实施方案1，快速验证眼部定位精度
2. **第二阶段**: 根据精度需求决定是否实施方案2
3. **可选**: 两个方案可并行实施，通过参数开关控制

---

## 附录

### A. 关键文件快速索引

| 功能 | 文件 | 行号 |
|------|------|------|
| 节点入口 | `src/main.cpp` | 18-24 |
| 参数声明 | `src/face_landmarks_det_node.cpp` | 36-47 |
| 推理调用 | `src/face_landmarks_det_node.cpp` | 466-471 |
| 后处理解析 | `src/face_landmarks_det_output_parser.cpp` | 21-258 |
| ROI归一化 | `src/face_landmarks_det_node.cpp` | 784-858 |
| 消息发布 | `src/face_landmarks_det_node.cpp` | 375 |
| 性能统计 | `src/face_landmarks_det_node.cpp` | 177-186 |

### B. 编译命令参考

```bash
# X5平台交叉编译
bash build.sh -p X5 -s face_landmarks_detection

# 本地编译 (需配置交叉编译环境)
colcon build --packages-select face_landmarks_detection
```

### C. 运行命令参考

```bash
# 离线推理
ros2 launch face_landmarks_detection face_landmarks_det_node.launch.py \
    feed_type:=1 \
    feed_image_path:=image.png \
    roi_xyxy:=251,242,328,337

# 在线推理 (联合人体检测)
ros2 launch face_landmarks_detection body_det_face_landmarks_det.launch.py
```

---

**文档版本**: v1.0
**生成日期**: 2026-01-27
**基于代码版本**: 2.3.1 (commit: b6160bd)

